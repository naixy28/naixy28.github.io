<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          JS Part 6 - Naixy28的博客 | Naixy28&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://naixy28.github.io/2015/08/05/2015-08-05-js-c6/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Naixy28&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://naixy28.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
                        
                    </div>
                    <h1>JS Part 6</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by naixy28 on
                        2015-08-05
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="javascript高级语言程序设计笔记-з」∠"><a href="#javascript高级语言程序设计笔记-з」∠" class="headerlink" title="javascript高级语言程序设计笔记_(:з」∠)_"></a>javascript高级语言程序设计笔记_(:з」∠)_</h1><h2 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h2><hr>
<p>###属性类型(不多解释)<br>分为数据属性与访问器属性</p>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><ul>
<li>configurable </li>
<li>enumerable</li>
<li>writable</li>
<li>value</li>
</ul>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><ul>
<li>configurable</li>
<li>enumerable</li>
<li>get</li>
<li>set</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123; <span class="comment">//字面量方式创建对象</span></div><div class="line">  _year: <span class="number">2004</span>; <span class="comment">//使用下划线表示只能通过对象方法访问的属性</span></div><div class="line">  edition: <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//设置单个属性，传入对象名、属性名、修改属性用的对象</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123; </div><div class="line"><span class="comment">// getter与setter若只定义了其中一个，则缺少另一个操作</span></div><div class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.year;</div><div class="line">  &#125;</div><div class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>)&#123;</div><div class="line">      <span class="keyword">this</span>._year = newValue;</div><div class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>; <span class="comment">//同步更新其他属性</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h3 id="创建对象的模式"><a href="#创建对象的模式" class="headerlink" title="创建对象的模式"></a>创建对象的模式</h3><p>js支持面向对象编程，但不使用类或接口，对象在执行过程中可以被增强，具有动态性而非严格定义的实体，可采用下列模式创建对象</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>为了<strong>减少</strong>使用字面量创建对象而产生的<strong>大量重复代码</strong>而诞生，用简单的函数创建对象并返回，被构造函数模式取代<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//建立新对象</span></div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.job = job;</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o; <span class="comment">//返回对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p><strong>工厂模式不能识别创建的对象类型</strong>，由此诞生构造函数模式，使用<code>new</code>操作符，缺点在于每个成员如函数<strong>无法复用</strong></p>
<ul>
<li>普通的类型定义<br>值得注意的<ul>
<li>没有显式的创建对象</li>
<li>赋值于<code>this</code>对象，与<code>new</code>操作符配合</li>
<li>没有<code>return</code></li>
<li>大写字母开头的类名，已经成为惯例，便于区分函数与构造函数</li>
<li>使用<code>new</code>操作符，其步骤是<ol>
<li>创建新对象</li>
<li>将构造函数的作用域赋给新对象（与this对应）</li>
<li>执行构造函数</li>
<li>返回新对象（对应没有<code>return</code>）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'haha'</span>,<span class="number">20</span>,<span class="string">'student'</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>缺点在于，每个实例都是全新创建的，例中的<code>sayName()</code>方法被<strong>重复创建</strong></p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>使用<code>prototype</code>属性指定需要共享的属性和方法，常常组合使用原型模式定义共享的属性和方法，用构造函数定义实例属性</p>
<ul>
<li>理解原型对象<br>只要创建了新函数，就会根据特定的规则创建一个<code>prototype</code>属性，指向原型对象。而原型对象默认会获得一个<code>constructor</code>属性，指向<code>prototype</code>属性所在的函数的指针。即<code>Person.prototype.constructor&lt;--&gt;Person</code>。新建的实例内部包含不可见的指针<code>[[Prototype]]</code>（部分浏览器支持<code>__proto__</code>属性），指向原型对象<br><img src="http://www.liaoxuefeng.com/files/attachments/001435299854512faf32868f60348be878982909b5a5d04000/l" alt="盗图"></li>
<li>一些方法<br>可以使用<code>Person.prototype.isPrototypeOf(person1)</code>和<code>Object.getPrototypeOf(person1)</code>方法判断和获得原型对象</li>
<li>链式的搜索过程<br>读取某个对象的属性时，会从实例本身开始搜索该属性，若不存在则向上搜索其原型对象直到找不到，因此当实例中找到了某个属性时，即使原型对象中存在同名属性，这个属性已经被实例中的属性<strong>屏蔽</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">'Nick'</span>;</div><div class="line">Person,prototype.age = <span class="number">20</span>; </div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.name = <span class="string">'Greg'</span>;</div><div class="line">alert(person1.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">//true 判断实例是否拥有自己的属性</span></div><div class="line">alert(<span class="string">'name'</span> <span class="keyword">in</span> person1); <span class="comment">//true 不论在原型中还是在实例中</span></div><div class="line">alert(person1.name); <span class="comment">//'Greg'</span></div><div class="line">alert(person2.name); <span class="comment">//'Nick'</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person1.name; <span class="comment">//使用delete删除实例中的属性</span></div><div class="line">alert(person1.name); <span class="comment">//'Nick'</span></div></pre></td></tr></table></figure>
<ul>
<li>for-in循环<br>只有<strong>可枚举</strong>的属性会被返回，包括了原型中的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj)&#123;</div><div class="line">  <span class="comment">//do something...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">//返回可枚举的属性名数组</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">//返回所有实例属性名</span></div></pre></td></tr></table></figure>
<ul>
<li>更简单的原型语法<br>使用字面量直接重写原型对象，相当于<strong>用新对象代替</strong>了原来的原型对象，会导致原先原型结构被破坏。新的原型对象需要<strong>手动定义</strong><code>constructor</code>属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(); <span class="comment">//先于重定义原型创建了实例</span></div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span> : Person,</div><div class="line">  <span class="attr">name</span> : <span class="string">'Nick'</span>,</div><div class="line">  <span class="attr">age</span> : <span class="number">20</span>,</div><div class="line">  <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend2 = <span class="keyword">new</span> Person(); <span class="comment">//后于重定义原型创建了实例</span></div><div class="line"></div><div class="line">friend.sayName() <span class="comment">//出错，其__proto__指向最初的原型对象</span></div><div class="line">friend2.sayName() <span class="comment">//Nick</span></div></pre></td></tr></table></figure>
<ul>
<li>原型对象的问题<br>不同于基本类型属性会被实例中同名属性屏蔽的特性，<strong>原型对象中的引用类型属性会被共享</strong>，解决方式是组合使用构造函数模式和原型模式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">name</span>: <span class="string">'Nick'</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">'Shelby'</span>,<span class="string">'Court'</span>],</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">'Van'</span>); <span class="comment">//并没有创建实例属性，本质上在修改原型属性</span></div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">//'Shelby','Court','Van'</span></div><div class="line">alert(person2.friends); <span class="comment">//'Shelby','Court','Van' person2与person1共享引用类型的原型属性</span></div></pre></td></tr></table></figure>
<h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>此为创建自定义类型的<strong>最常见方式</strong>，前面讲的都是为了这个做铺垫。特点是，使用构造函数模式定义实例属性，而使用原型模式用于定义方法和共享的属性。结果每个实例都会有自己的一份实例属性的副本，同时共享对方法的引用，节省了内存。另外，这种模式还支持向构造函数传递参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.friedns = [<span class="string">'shelby'</span>,<span class="string">'court'</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nick'</span>,<span class="number">29</span>,<span class="string">'sf'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>,<span class="number">20</span>,<span class="string">'doc'</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">'Van'</span>);</div><div class="line">alert(person1.friends); <span class="comment">//'Shelby','Court','Van'</span></div><div class="line">alert(person2.friends); <span class="comment">//'Shelby','Court'</span></div></pre></td></tr></table></figure></p>
<h4 id="其他的构造模式"><a href="#其他的构造模式" class="headerlink" title="其他的构造模式"></a>其他的构造模式</h4><ul>
<li><p>动态原型模式<br>组合模式把创建自定义类型分成了两部分，而动态原型模式通过使原型内的属性在构造函数内初始化（如果必要）来解决这个‘问题’</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  </div><div class="line">  <span class="comment">//方法</span></div><div class="line">  <span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>)&#123;  <span class="comment">//每次构造时判断这是不是第一个本类的实例，由此决定是否要初始化原型</span></div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 用此方法只需判断任意一个原型属性是否存在</span></div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>寄生构造函数模式<br>本质上是使用了<code>new</code>的工厂模式，作用在于临时增强某个已有类型（主要是原生类型如Array）</p>
</li>
<li>稳妥构造函数模式<br>稳妥对象即没有公共属性，其方法也不引用this对象，用于安全的环境</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job)&#123;</div><div class="line">  var o =new Object();</div><div class="line">  o.sayName=function()&#123;</div><div class="line">    alert(name);</div><div class="line">  &#125;;</div><div class="line">  return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = Person('Nick' , '20, 'teacher');</div><div class="line">friend.sayName(); //除了用sayName方法，无法访问到name属性</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>全靠原型链，图片书上有</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>使用原型链继承，即将超类的实例赋值给子类的构造函数的原型，缺点在于子类实例共享继承的属性和方法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">  this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function()&#123;</div><div class="line">  return this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType()[</div><div class="line">  this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承了supertype</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">Subtype.prototype.getSubValue = function()&#123;</div><div class="line">  return this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue()); //true</div></pre></td></tr></table></figure></p>
<p>上例中，继承是通过创建<code>SuperType</code>实例，并将其赋给<code>SubType.prototype</code>实现的。另外，此时<code>instance.constructor</code>指向的是<code>SuperType</code></p>
<p>上例中搜索原型链的步骤如下  </p>
<ol>
<li>搜索实例</li>
<li>搜索<code>SybType.prototype</code></li>
<li>搜索<code>SuperType.prototype</code></li>
<li>搜索默认的原型，即<code>Object.prototype</code>，此乃所有引用类型都继承<code>Object</code>的本质</li>
</ol>
<p><strong>原型链的问题</strong>  </p>
<ul>
<li>与构造函数类似，由于继承自超类的实例，原本<strong>超类实例中的实例属性就会变成子类的原型属性</strong>了，对于引用对象来说这就意味着原型属性<strong>被所有的子类实例共享使用</strong></li>
<li>单独使用原型链时，不能像超类的构造函数中<strong>传递参数</strong></li>
</ul>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>为了解决单独使用原型链的问题，诞生了这种方法，又叫做伪造对象或经典继承。基本思想是在子类构造函数中调用超类构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</div><div class="line">  <span class="keyword">this</span>.name = name; <span class="comment">//演示可以传递参数</span></div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//使拥有实例属性</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>,<span class="string">'Nick'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，借用构造函数的方法由于不能复用函数也不单独使用</p>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>在用原型链继承的同时，借用超类的构造函数构造子类实例，使每个实例都有自己的属性，同时保证只使用构造函数模式定义类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name= name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.syaName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  <span class="comment">//继承属性</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>.name);</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>在不必定义构造函数的情况下继承，即基于已有对象实现继承，本质是执行给定对象的浅复制，对副本再进行增强改造<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">  F.prototype = o;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">//返回的对象与被浅复制的对象共享一个原型对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>ECMAScript5新增了<code>Object.create()</code>方法规范了原型式继承（和上例作用一样），可以额外增加第二个参数是<strong>为新对象定义额外属性的对象</strong></li>
<li>在没必要创建构造函数，只是想让一个对象与另一个对象保持相似的情况下可以使用原型式继承</li>
</ul>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>类似原型式继承，常与组合继承一起使用，减少调用超类的构造函数次数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//此处object函数不是必须的，任何能返回新对象的函数都适用</span></div><div class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'hi'</span>);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> clone;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>最有效的继承方式，利用寄生式继承，避免了为子类指定原型而调用超类的构造函数，转而用超类原型的一个副本作为子类的原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来代替 subType.prototype = new superType()的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123; </div><div class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//复制了超类的原型对象</span></div><div class="line">  prototype.constructor = subType; <span class="comment">//将新的原型对象与子类相关联</span></div><div class="line">  subType.prototype = prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//say something</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">inheritPrototype(SubType,SuperType); <span class="comment">//就是他！</span></div><div class="line">SubType.prototype.sayAge= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="http://ww4.sinaimg.cn/mw690/86444fb9gw1evxh5vav1rj20it0aa758.jpg" alt="test"><br>试着画了个图表示寄生组合式继承，可以看出<code>SubType</code>的原型对象因为不是调用<code>SuperType</code>的构造函数得到所以没有多余属性（<code>name</code>和<code>colors</code>）<br><img src="http://ww2.sinaimg.cn/mw690/86444fb9gw1evxhapyhstj20by04g74c.jpg" alt="test"><br>上图为书中的组合继承示意图</p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2015/08/06/2015-08-06-js-c7/" data-toggle="tooltip" data-placement="top" title="JS Part 7">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2015/08/04/2015-08-04-js-c5/" data-toggle="tooltip" data-placement="top" title="JS Part 5">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hexo-theme-huxblog";
    var disqus_identifier = "https://naixy28.github.io/2015/08/05/2015-08-05-js-c6/";
    var disqus_url = "https://naixy28.github.io/2015/08/05/2015-08-05-js-c6/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/yuan-yang-ryan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/naixy28">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/ryan-yuan-68813a103">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Naixy28&#39;s Blog 2017 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://naixy28.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="https://naixy28.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
