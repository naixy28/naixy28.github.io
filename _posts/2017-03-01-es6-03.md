---
layout: article
title: Promise
excerpt: ES6笔记 Part 3 - Promise
category: tech
tags: javascript es6
---
# Promise

## 基本概念
- 一种异步方案，避免回调地狱
- 内置三种状态，只能由1变为2或3的其中一种
  1. `Pending` -- 进行中
  2. `Resolved` -- 完成
  3. `Rejected` -- 失败
- 缺点
  1. 一旦新建就立即执行，不会取消
  2. 若不设置回调，则无法捕获错误

## 基本用法
使用`Promise`对象生成实例，接受一个函数作参数，函数有两个参数
- `resolve()` -- `Pending` -> `Resolved`
- `reject()` -- `Pending` -> `Rejected`

```
var promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
```

实例生成后，用`then`方法分别指定两个状态的回调

```
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
```

执行顺序的例子

```
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');  //立即执行
  resolve(); 
});

promise.then(function() { //作为microtask在执行栈空之后执行
  console.log('Resolved.'); 
});

setTimeout(console.log,10,'Time out!'); //作为task执行

console.log('Hi!'); //立即执行

// Promise
// Hi!
// Resolved
// Time out!
```

用Promise包装的Ajax

```
var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject){
    var client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    client.send();

    function handler() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
  });

  return promise;
};

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
```

对于**resolve与reject的参数**，若传的参数是个Promise，表示异步操作的结果是另一个异步操作

```
var p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

var p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

//p1和p2同时开始执行，p2的Pending状态的改变需要等p1的状态改变

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// 流程： 1s -> p2的resolve执行,p2 Pending, p1 Pending -> 2s -> p1 Rejected Error: fail，p2 Rejected
//共3s
```

## then方法
- then方法默认有两个function作参数，分别是两种终状态的的回调函数
- then方法return的内容可以被下一个then作为参数接收，继而形成链式调用，返回值的逻辑与resolve|reject相同

```
//链式调用的Promise的执行有先后顺序，等前一个Promise的状态改变后才会执行后一个Promise
getJSON("/post/1.json").then(
  post => getJSON(post.commentURL)
).then(
  comments => console.log("Resolved: ", comments),
  err => console.log("Rejected: ", err)
);
```

## catch方法
- catch方法是`.then(null, rejection)`的别名
- 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法，因为error会向后**冒泡**
- 捕获和手动抛出error使用`try catch`和`throw new Error('text')`


```
//以下两种方法等价
// 写法一
var promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});

// 写法二
var promise = new Promise(function(resolve, reject) {
  reject(new Error('test'));
});
promise.catch(function(error) {
  console.log(error);
});
```

如果Promise状态已经改变，再抛出error是不会在Promise内被捕获的

```
var promise = new Promise(function(resolve, reject) {
  resolve('ok');
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
```

catch函数后可以继续调用then方法，执行then内部的回调

catch函数内可以继续抛出error，由下一个catch捕获

## Promise.all()
- 用于包装多个Promise成一个新的Promise实例，Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例
- 若入参不是Promise对象，自动Promise.resolve()转换

```
//基本形态
var p = Promise.all([p1, p2, p3]);

// 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function (id) {
  return getJSON("/post/" + id + ".json");
});

Promise.all(promises).then(function (posts) {
  // ...
}).catch(function(reason){
  // ...
});
```

p的状态由p1 p2 p3的状态决定
- 若三个全部resolved,p也变为resolved, p1 p2 p3的返回结果组成一个数组传入p的回调
- 若任意一个pn返回rejected，p变为rejected，第一个pn的reject传给p

## Promise.race()
- 与all的入参相同，但根据第一个resolve的Promise结果执行then
- 若入参不是Promise对象，自动Promise.resolve()转换

```
//基本形态
var p = Promise.race([p1, p2, p3]);

//上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数
//const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);
p.then(response => console.log(response));
p.catch(error => console.log(error));
```

## Promise.resolve()
```
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

Promise.resolve的参数分四种情况，Promise实例、thenable对象、普通的值、空

```
//情况1
//直接返回原Promise对象


//情况2
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function(value) {
  console.log(value);  // 42
});

//情况3
var p = Promise.resolve('Hello');

p.then(function (s){
  console.log(s)
});
// Hello

//情况4
//返回一个立即resolve的Promise对象
var p = Promise.resolve();

p.then(function () {
  // ...
});
```

**立即resolve的Promise对象**的then会在本轮事件循环结束时执行（microtask），不会放到下一次事件循环的头部


## Promise.reject()
Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。
